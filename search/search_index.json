{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RbxNet RbxNet is a networking library for Roblox, built in TypeScript. It simplifies the creation and management of networking in Roblox. Info While RbxNet is primarily a Roblox TypeScript library, it also is available for Lua. Features \u00b6 Creation & Usage of remotes through \"IDs\". The actual remotes are managed by Net. More explicit, contextual APIs. Server objects are explicitly for the server, Client objects explicitly for the client. Asynchronous remote functions ( Net*AsyncFunction ) - Which unlike regular remote functions allow timeouts and safely calling clients without issues. Asynchronous methods - part of being a roblox-ts built library is the support for Promise . Caching - Results from RemoteFunctions can be cached on the client for a set amount of time. Throttling - RemoteFunctions and RemoteEvents can be set to throttle requests. Type Safety - Using a library such as t , you can explicitly set what your RemoteFunctions/RemoteEvents accept as valid arguments. Any invalid arguments will be discarded. GlobalServerEvents - Special RemoteEvent-like objects that use MessagingService to communicate cross-server. Limitations of MessagingService are automatically handled through it. Serialization Helpers - Net.Serialize, Net.Deserialize, Net.IsSerializable","title":"Home"},{"location":"#features","text":"Creation & Usage of remotes through \"IDs\". The actual remotes are managed by Net. More explicit, contextual APIs. Server objects are explicitly for the server, Client objects explicitly for the client. Asynchronous remote functions ( Net*AsyncFunction ) - Which unlike regular remote functions allow timeouts and safely calling clients without issues. Asynchronous methods - part of being a roblox-ts built library is the support for Promise . Caching - Results from RemoteFunctions can be cached on the client for a set amount of time. Throttling - RemoteFunctions and RemoteEvents can be set to throttle requests. Type Safety - Using a library such as t , you can explicitly set what your RemoteFunctions/RemoteEvents accept as valid arguments. Any invalid arguments will be discarded. GlobalServerEvents - Special RemoteEvent-like objects that use MessagingService to communicate cross-server. Limitations of MessagingService are automatically handled through it. Serialization Helpers - Net.Serialize, Net.Deserialize, Net.IsSerializable","title":"Features"},{"location":"api-reference/","text":"Functions \u00b6 Net.CreateFunction \u00b6 function Net . CreateFunction ( name : string ) : NetServerFunction Creates a new NetServerFunction with the specified name . Net.CreateEvent \u00b6 function Net . CreateEvent ( name : string ) : NetServerEvent Creates a new NetServerEvent with the specified name . Net.Serialize \u00b6 Added in 1.0.13 function Net . Serialize < T > ( object : T ) : Serializable < T > ; Serializes the object. Serialization Priority If there's a serialize method in the object, that will be called otherwise it will iterate through the properties of the object. The output will be a regular table, that can be used with the networking objects. Net.Deserialize \u00b6 Added in 1.0.13 function Deserialize < T > ( object : Serializable < T > , deserializer : ( value : Serializable < T > ) => T ) : T ; Deserializes the given serialized object using the specified deserializer Deserializer If the deserializer is a function, it will call it with the first argument being the serialized object. If the deserializer is a class with a static deserialize method, that will be called Otherwise if it is a table, it will set the properties Net.IsSerializable \u00b6 Added in 1.0.13 function IsSerializable ( value : unknown ) : boolean ; Checks that the object is serializable False conditions This function will return false if: The value is not a primitive (number, boolean, string) The value is a table with a metatable The table has mixed values (keys and indexes) Net.SetConfiguration \u00b6 Net.SetClientConfiguration \u00b6 Net.GetConfiguration \u00b6 Classes \u00b6 NetServerEvent \u00b6 The server version of an event. class NetServerEvent { constructor ( name : string ); } Creation: TypeScript // OOP const event = new Net . ServerEvent ( \"NameHere\" ); // Using const event = Net . CreateEvent ( \"NameHere\" ); Lua -- OOP local event = Net . ServerEvent . new ( \"NameHere\" ) -- Using CreateEvent local event = Net . CreateEvent ( \"NameHere\" ) NetServerFunction \u00b6 The server version of a function. NetServerAsyncFunction \u00b6 Added in 1.2.0 NetGlobalServerEvent \u00b6 Added in 1.0.13 NetGlobalEvent \u00b6 Added in 1.0.13 NetClientEvent \u00b6 The client version of an event. class NetClientEvent { constructor ( name : string ); } Creation: TypeScript // OOP const event = new Net . ClientEvent ( \"NameHere\" ); // Async const event = Net . WaitForClientEventAsync ( \"NameHere\" ). then ( event => { // do stuff with 'event' }); Lua -- OOP local event = Net . ClientEvent . new ( \"NameHere\" ) -- Async local event = Net . WaitForClientEventAsync ( \"NameHere\" ): andThen ( function ( event ) -- do stuff with 'event' end ) NetClientFunction \u00b6 The client version of a function. NetClientAsyncFunction \u00b6 Added in 1.2.0","title":"Net namespace"},{"location":"api-reference/#functions","text":"","title":"Functions"},{"location":"api-reference/#netcreatefunction","text":"function Net . CreateFunction ( name : string ) : NetServerFunction Creates a new NetServerFunction with the specified name .","title":"Net.CreateFunction"},{"location":"api-reference/#netcreateevent","text":"function Net . CreateEvent ( name : string ) : NetServerEvent Creates a new NetServerEvent with the specified name .","title":"Net.CreateEvent"},{"location":"api-reference/#netserialize","text":"Added in 1.0.13 function Net . Serialize < T > ( object : T ) : Serializable < T > ; Serializes the object. Serialization Priority If there's a serialize method in the object, that will be called otherwise it will iterate through the properties of the object. The output will be a regular table, that can be used with the networking objects.","title":"Net.Serialize"},{"location":"api-reference/#netdeserialize","text":"Added in 1.0.13 function Deserialize < T > ( object : Serializable < T > , deserializer : ( value : Serializable < T > ) => T ) : T ; Deserializes the given serialized object using the specified deserializer Deserializer If the deserializer is a function, it will call it with the first argument being the serialized object. If the deserializer is a class with a static deserialize method, that will be called Otherwise if it is a table, it will set the properties","title":"Net.Deserialize"},{"location":"api-reference/#netisserializable","text":"Added in 1.0.13 function IsSerializable ( value : unknown ) : boolean ; Checks that the object is serializable False conditions This function will return false if: The value is not a primitive (number, boolean, string) The value is a table with a metatable The table has mixed values (keys and indexes)","title":"Net.IsSerializable"},{"location":"api-reference/#netsetconfiguration","text":"","title":"Net.SetConfiguration"},{"location":"api-reference/#netsetclientconfiguration","text":"","title":"Net.SetClientConfiguration"},{"location":"api-reference/#netgetconfiguration","text":"","title":"Net.GetConfiguration"},{"location":"api-reference/#classes","text":"","title":"Classes"},{"location":"api-reference/#netserverevent","text":"The server version of an event. class NetServerEvent { constructor ( name : string ); } Creation: TypeScript // OOP const event = new Net . ServerEvent ( \"NameHere\" ); // Using const event = Net . CreateEvent ( \"NameHere\" ); Lua -- OOP local event = Net . ServerEvent . new ( \"NameHere\" ) -- Using CreateEvent local event = Net . CreateEvent ( \"NameHere\" )","title":"NetServerEvent"},{"location":"api-reference/#netserverfunction","text":"The server version of a function.","title":"NetServerFunction"},{"location":"api-reference/#netserverasyncfunction","text":"Added in 1.2.0","title":"NetServerAsyncFunction"},{"location":"api-reference/#netglobalserverevent","text":"Added in 1.0.13","title":"NetGlobalServerEvent"},{"location":"api-reference/#netglobalevent","text":"Added in 1.0.13","title":"NetGlobalEvent"},{"location":"api-reference/#netclientevent","text":"The client version of an event. class NetClientEvent { constructor ( name : string ); } Creation: TypeScript // OOP const event = new Net . ClientEvent ( \"NameHere\" ); // Async const event = Net . WaitForClientEventAsync ( \"NameHere\" ). then ( event => { // do stuff with 'event' }); Lua -- OOP local event = Net . ClientEvent . new ( \"NameHere\" ) -- Async local event = Net . WaitForClientEventAsync ( \"NameHere\" ): andThen ( function ( event ) -- do stuff with 'event' end )","title":"NetClientEvent"},{"location":"api-reference/#netclientfunction","text":"The client version of a function.","title":"NetClientFunction"},{"location":"api-reference/#netclientasyncfunction","text":"Added in 1.2.0","title":"NetClientAsyncFunction"},{"location":"caching/","text":"Functions in RbxNet can be set to cache the return value. This means any subsequent requests to the function will return a local value rather than continually request the value from the server. Supported By ServerFunction Basic Usage \u00b6 TypeScript const exampleCachedRemote = new Net . ServerFunction ( \"Example\" ); exampleCachedRemote . SetClientCache ( 10 ); exampleCachedRemote . SetCallback (( player ) => { return tick (); }) Lua local exampleCachedRemote = Net . ServerFunction . new ( \"Example\" ) exampleCachedRemote : SetClientCache ( 10 ) exampleCachedRemote : SetCallback ( function ( player ) return tick () end ) With the above, when it's called it will only return a fresh tick count from the server every 10 seconds.","title":"Caching"},{"location":"caching/#basic-usage","text":"TypeScript const exampleCachedRemote = new Net . ServerFunction ( \"Example\" ); exampleCachedRemote . SetClientCache ( 10 ); exampleCachedRemote . SetCallback (( player ) => { return tick (); }) Lua local exampleCachedRemote = Net . ServerFunction . new ( \"Example\" ) exampleCachedRemote : SetClientCache ( 10 ) exampleCachedRemote : SetCallback ( function ( player ) return tick () end ) With the above, when it's called it will only return a fresh tick count from the server every 10 seconds.","title":"Basic Usage"},{"location":"events/","text":"Events are useful for messages you want to send to either a player or the server, that expects no response. This could be things like the player's inventory updating, the player unlocking an achievement and so forth. Overview \u00b6 RbxNet has two main event classes: ServerEvent ( NetServerEvent ) This class handles events from the server ClientEvent ( NetClientEvent ) This class handles events from the clients (players) There are also other secondary event classes: ServerThrottledEvent , ServerThrottledFunction which are covered in Throttling GlobalEvent and GlobalServerEvent which are covered in Global Events Server Event \u00b6 Creating a ServerEvent \u00b6 You can create a server event with the following Procedural \u00b6 TypeScript const yourEventName = Net . CreateEvent ( \"YourEventName\" ); Lua local yourEventName = Net . CreateEvent ( \"YourEventName\" ); Object-oriented \u00b6 TypeScript const yourEventName = new Net . ServerEvent ( \"YourEventName\" ); Lua local yourEventName = Net . ServerEvent . new ( \"YourEventName\" ) Asynchronously \u00b6 TypeScript Net . GetServerEventAsync ( \"YourEventName\" ). then ( event => { // ... Do stuff with 'event' }); Lua Net . GetServerEventAsync ( \"YourEventName\" ): andThen ( function ( event ) -- ... Do stuff with 'event' end ) Hooking up the server to listen \u00b6 Now that we've created a server event, we want to be able to listen out for any messages sent by the client. (player) That can be achieved with the Connect method. TypeScript const yourEventName = Net . CreateEvent ( \"YourEventName\" ); yourEventName . Connect (( player : Player , ... args : Array < unknown > ) => { // ... handle messages received here }); Lua local yourEventName = Net . CreateEvent ( \"YourEventName\" ) yourEventName : Connect ( function ( player , ...) local args = {...} -- handle messages recieved here end ) Sending events to the client (Player) \u00b6 TypeScript // assuming we're still using yourEventName as the Event // This would send \"Hello, World!\" to the \"YourEventName\" remote. yourEventName . SendToPlayer ( game . Players . Player1 , \"Hello, World!\" ); // You can also send to all players yourEventName . SendToAllPlayers ( \"Hello, World!\" ); // or send to specific players yourEventName . SendToPlayers ([ game . Players . Player1 , game . Players . Player3 ], \"Hello, World!\" ); Lua -- assuming we're still using yourEventName as the Event -- This would send \"Hello, World!\" to the \"YourEventName\" remote. yourEventName : SendToPlayer ( game . Players . Player1 , \"Hello, World!\" ) -- You can also send to all players yourEventName : SendToAllPlayers ( \"Hello, World!\" ) -- or send to specific players yourEventName : SendToPlayers ({ game . Players . Player1 , game . Players . Player3 }, \"Hello, World!\" ) Client Event \u00b6 An event must first be created on the server using ServerEvent , or it will error. If you don't want it to error, use the asynchronous method of getting the event. Getting a ClientEvent \u00b6 You can create a client event with the following Asynchronously (Recommended) \u00b6 TypeScript const yourEventName = Net . WaitForClientEventAsync ( \"YourEventName\" ). then ( event => { // ... connect to the event here, fire the event, etc. }); Lua local yourEventName = Net . WaitForClientEventAsync ( \"YourEventName\" ): andThen ( function ( event ) -- Connect to the event here, fire the event, etc. end ) Object-oriented \u00b6 This will error if the event does not exist on the server! TypeScript const yourEventName = new Net . ClientEvent ( \"YourEventName\" ); Lua local yourEventName = Net . ClientEvent . new ( \"YourEventName\" ); Hooking up the client to listen \u00b6 Just like the server event, we can also connect on the client to listen to any messages sent by the server. That can be achieved with the Connect method. TypeScript Net . WaitForClientEventAsync ( \"YourEventName\" ). then ( event => { event . Connect ((... args : Array < unknown > ) => { // ... do things with the recieved events. }); }); Lua Net . WaitForClientEventAsync ( \"YourEventName\" ): andThen ( function ( event ) event : Connect ( function (...) local args = {...} -- ... do things with the recieved events. end ) end ) Sending events to the server \u00b6 TypeScript // assuming we're still using yourEventName as the Event // This would send \"Hello, World!\" to the \"YourEventName\" remote, to the server. yourEventName . SendToServer ( \"Hello, World!\" ); Lua -- assuming we're still using yourEventName as the Event -- This would send \"Hello, World!\" to the \"YourEventName\" remote, to the server. yourEventName : SendToServer ( \"Hello, World!\" )","title":"Events"},{"location":"events/#overview","text":"RbxNet has two main event classes: ServerEvent ( NetServerEvent ) This class handles events from the server ClientEvent ( NetClientEvent ) This class handles events from the clients (players) There are also other secondary event classes: ServerThrottledEvent , ServerThrottledFunction which are covered in Throttling GlobalEvent and GlobalServerEvent which are covered in Global Events","title":"Overview"},{"location":"events/#server-event","text":"","title":"Server Event"},{"location":"events/#creating-a-serverevent","text":"You can create a server event with the following","title":"Creating a ServerEvent"},{"location":"events/#procedural","text":"TypeScript const yourEventName = Net . CreateEvent ( \"YourEventName\" ); Lua local yourEventName = Net . CreateEvent ( \"YourEventName\" );","title":"Procedural"},{"location":"events/#object-oriented","text":"TypeScript const yourEventName = new Net . ServerEvent ( \"YourEventName\" ); Lua local yourEventName = Net . ServerEvent . new ( \"YourEventName\" )","title":"Object-oriented"},{"location":"events/#asynchronously","text":"TypeScript Net . GetServerEventAsync ( \"YourEventName\" ). then ( event => { // ... Do stuff with 'event' }); Lua Net . GetServerEventAsync ( \"YourEventName\" ): andThen ( function ( event ) -- ... Do stuff with 'event' end )","title":"Asynchronously"},{"location":"events/#hooking-up-the-server-to-listen","text":"Now that we've created a server event, we want to be able to listen out for any messages sent by the client. (player) That can be achieved with the Connect method. TypeScript const yourEventName = Net . CreateEvent ( \"YourEventName\" ); yourEventName . Connect (( player : Player , ... args : Array < unknown > ) => { // ... handle messages received here }); Lua local yourEventName = Net . CreateEvent ( \"YourEventName\" ) yourEventName : Connect ( function ( player , ...) local args = {...} -- handle messages recieved here end )","title":"Hooking up the server to listen"},{"location":"events/#sending-events-to-the-client-player","text":"TypeScript // assuming we're still using yourEventName as the Event // This would send \"Hello, World!\" to the \"YourEventName\" remote. yourEventName . SendToPlayer ( game . Players . Player1 , \"Hello, World!\" ); // You can also send to all players yourEventName . SendToAllPlayers ( \"Hello, World!\" ); // or send to specific players yourEventName . SendToPlayers ([ game . Players . Player1 , game . Players . Player3 ], \"Hello, World!\" ); Lua -- assuming we're still using yourEventName as the Event -- This would send \"Hello, World!\" to the \"YourEventName\" remote. yourEventName : SendToPlayer ( game . Players . Player1 , \"Hello, World!\" ) -- You can also send to all players yourEventName : SendToAllPlayers ( \"Hello, World!\" ) -- or send to specific players yourEventName : SendToPlayers ({ game . Players . Player1 , game . Players . Player3 }, \"Hello, World!\" )","title":"Sending events to the client (Player)"},{"location":"events/#client-event","text":"An event must first be created on the server using ServerEvent , or it will error. If you don't want it to error, use the asynchronous method of getting the event.","title":"Client Event"},{"location":"events/#getting-a-clientevent","text":"You can create a client event with the following","title":"Getting a ClientEvent"},{"location":"events/#asynchronously-recommended","text":"TypeScript const yourEventName = Net . WaitForClientEventAsync ( \"YourEventName\" ). then ( event => { // ... connect to the event here, fire the event, etc. }); Lua local yourEventName = Net . WaitForClientEventAsync ( \"YourEventName\" ): andThen ( function ( event ) -- Connect to the event here, fire the event, etc. end )","title":"Asynchronously (Recommended)"},{"location":"events/#object-oriented_1","text":"This will error if the event does not exist on the server! TypeScript const yourEventName = new Net . ClientEvent ( \"YourEventName\" ); Lua local yourEventName = Net . ClientEvent . new ( \"YourEventName\" );","title":"Object-oriented"},{"location":"events/#hooking-up-the-client-to-listen","text":"Just like the server event, we can also connect on the client to listen to any messages sent by the server. That can be achieved with the Connect method. TypeScript Net . WaitForClientEventAsync ( \"YourEventName\" ). then ( event => { event . Connect ((... args : Array < unknown > ) => { // ... do things with the recieved events. }); }); Lua Net . WaitForClientEventAsync ( \"YourEventName\" ): andThen ( function ( event ) event : Connect ( function (...) local args = {...} -- ... do things with the recieved events. end ) end )","title":"Hooking up the client to listen"},{"location":"events/#sending-events-to-the-server","text":"TypeScript // assuming we're still using yourEventName as the Event // This would send \"Hello, World!\" to the \"YourEventName\" remote, to the server. yourEventName . SendToServer ( \"Hello, World!\" ); Lua -- assuming we're still using yourEventName as the Event -- This would send \"Hello, World!\" to the \"YourEventName\" remote, to the server. yourEventName : SendToServer ( \"Hello, World!\" )","title":"Sending events to the server"},{"location":"lua-install/","text":"Git Submodule \u00b6 Info This process requires knowledge of rojo . To use RbxNet as a git submodule, you need to do the following: Run the command git submodule add https://github.com/roblox-aurora/rbx-net.git <targetfolder> -b lualib e.g. if you wanted it in modules/net: git submodule add https://github.com/roblox-aurora/rbx-net.git modules/net -b lualib Then in your *.project.json folder, simply point it to <targetfolder> for the Lua output (e.g. in the above example, modules/net . Roblox Model \u00b6 You can find the .rbxmx file in releases . Simply just drag the downloaded file into studio and move it to ReplicatedStorage.","title":"Install for Lua"},{"location":"lua-install/#git-submodule","text":"Info This process requires knowledge of rojo . To use RbxNet as a git submodule, you need to do the following: Run the command git submodule add https://github.com/roblox-aurora/rbx-net.git <targetfolder> -b lualib e.g. if you wanted it in modules/net: git submodule add https://github.com/roblox-aurora/rbx-net.git modules/net -b lualib Then in your *.project.json folder, simply point it to <targetfolder> for the Lua output (e.g. in the above example, modules/net .","title":"Git Submodule"},{"location":"lua-install/#roblox-model","text":"You can find the .rbxmx file in releases . Simply just drag the downloaded file into studio and move it to ReplicatedStorage.","title":"Roblox Model"},{"location":"robloxts-install/","text":"Info The TypeScript binding for RbxNet uses roblox-ts . To use the TypeScript version of RbxNet, you must install it first. Node Module \u00b6 RbxNet is available on NPM. To install it to your roblox-ts project, type the following in command line/terminal npm i @rbxts/net Once you have the module installed, you can then use it in code by importing it as such: TypeScript import Net from \"@rbxts/net\" ;","title":"Install for TypeScript"},{"location":"robloxts-install/#node-module","text":"RbxNet is available on NPM. To install it to your roblox-ts project, type the following in command line/terminal npm i @rbxts/net Once you have the module installed, you can then use it in code by importing it as such: TypeScript import Net from \"@rbxts/net\" ;","title":"Node Module"},{"location":"throttling/","text":"When using remotes in Roblox, you might want to limit the amount of times a user can send a request to a remote event or remote function. Supported By ServerEvent >= 1.3.0 ServerFunction >= 1.3.0 ServerThrottledEvent deprecated ServerThrottledFunction deprecated Basic Usage \u00b6 Say for example we have a remote object that fetches a list of items. Ideally we wouldn't want the user to be able to continuously spam it. TypeScript const fetchItemList = new Net . ServerFunction ( \"FetchItemList\" ); fetchItemList . SetRateLimit ( 1 ); fetchItemList . SetCallback (( player ) => { // ... return data ; }); Lua local fetchItemList = Net . ServerFunction . new ( \"FetchItemList\" ) fetchItemList : SetRateLimit ( 1 ) fetchItemList : SetCallback ( function ( player ) -- ... return data end ) What the above does, is it creates a server function and then sets a limit of 1 request per minute.","title":"Throttling"},{"location":"throttling/#basic-usage","text":"Say for example we have a remote object that fetches a list of items. Ideally we wouldn't want the user to be able to continuously spam it. TypeScript const fetchItemList = new Net . ServerFunction ( \"FetchItemList\" ); fetchItemList . SetRateLimit ( 1 ); fetchItemList . SetCallback (( player ) => { // ... return data ; }); Lua local fetchItemList = Net . ServerFunction . new ( \"FetchItemList\" ) fetchItemList : SetRateLimit ( 1 ) fetchItemList : SetCallback ( function ( player ) -- ... return data end ) What the above does, is it creates a server function and then sets a limit of 1 request per minute.","title":"Basic Usage"},{"location":"type-safety/","text":"Type Safety \u00b6 It's important when you recieve events or calls from the server that you ensure the types are correct, otherwise unwanted errors may pop up. By default, events and callbacks are typed to unknown[] . This may become a bit problematic when you're trying to set specific parameter types as such: TypeScript const addItemToPlayer = new Net . ServerEvent ( \"AddItemToPlayer\" ); addItemToPlayer . Connect (( player : Player , itemId : string , amount : number ) => { // itemId and amount will show with an error // since unknown cannot be converted to number }) Lua local addItemToPlayer = Net . ServerEvent . new ( \"AddItemToPlayer\" ) addItemToPlayer : Connect ( function ( player , itemId , amount ) -- itemId and amount could be anything here in Lua -- This can lead to bugs, especially with exploiters end ) How to enforce types \u00b6 The constructors for Net.ServerEvent , Net.ServerFunction and Net.ServerAsyncFunction all take extra parameters that are referred to as \"Type Guards\". A type guard is a basic function which takes in a value, and returns whether or not the value matches a certain criteria to be of that type. TypeScript function isString ( value : unknown ) : value is string { return typeIs ( value , \"string\" ); } function isNumber ( value : unknown ) : value is number { return typeIs ( value , \"number\" ); } Lua function isString ( value ) return type ( value ) == \"string\" end function isNumber ( value ) return type ( value ) == \"number\" end So in our above case, if we wanted to enforce our RemoteEvent to only take in a string, and a number: TypeScript import Net from \"@rbxts/net\" ; const addItemToPlayer = new Net . ServerEvent ( \"AddItemToPlayer\" , isString , isNumber ); // Take note of 'isString' and 'isNumber' use in the constructor here. // Also the types can be omitted as TypeScript knows what the types are now. addItemToPlayer . Connect (( player , itemId , amount ) => { // itemId will always be a string // amount will always be a number // If either are wrong, it will get discarded }) Lua local Net = require ( path_to_net ) local addItemToPlayer = Net . ServerEvent . new ( \"AddItemToPlayer\" , isString , isNumber ) -- Take note of 'isString' and 'isNumber' use in the constructor here. addItemToPlayer : Connect ( function ( player , itemId , amount ) -- itemId will always be a string -- amount will always be a number -- If either are wrong, it will get discarded end ) Using an existing type guard library \u00b6 Writing your own functions for type guards, while doable can get tedious. There is already a library called 't' which is a good solution for this. TypeScript \u00b6 You can install it using: npm i @rbxts/t Then with our above example, simply replace isString and isNUmber with t.string and t.number . There are also other type guards in that library that you could use for different argument types. import t from \"@rbxts/t\" ; import Net from \"@rbxts/net\" ; const addItemToPlayer = new Net . ServerEvent ( \"AddItemToPlayer\" , t . string , t . number ); addItemToPlayer . Connect (( player , itemId , amount ) => { // itemId will always be a string // amount will always be a number // If either are wrong, it will get discarded }) Lua \u00b6 If you want the Lua version of t, it is available here . local Net = require ( path_to_net ) local t = require ( path_to_t ) local addItemToPlayer = Net . ServerEvent . new ( \"AddItemToPlayer\" , t . string , t . number ) addItemToPlayer : Connect ( function ( player , itemId , amount ) -- itemId will always be a string -- amount will always be a number -- If either are wrong, it will get discarded end )","title":"Type Safety"},{"location":"type-safety/#type-safety","text":"It's important when you recieve events or calls from the server that you ensure the types are correct, otherwise unwanted errors may pop up. By default, events and callbacks are typed to unknown[] . This may become a bit problematic when you're trying to set specific parameter types as such: TypeScript const addItemToPlayer = new Net . ServerEvent ( \"AddItemToPlayer\" ); addItemToPlayer . Connect (( player : Player , itemId : string , amount : number ) => { // itemId and amount will show with an error // since unknown cannot be converted to number }) Lua local addItemToPlayer = Net . ServerEvent . new ( \"AddItemToPlayer\" ) addItemToPlayer : Connect ( function ( player , itemId , amount ) -- itemId and amount could be anything here in Lua -- This can lead to bugs, especially with exploiters end )","title":"Type Safety"},{"location":"type-safety/#how-to-enforce-types","text":"The constructors for Net.ServerEvent , Net.ServerFunction and Net.ServerAsyncFunction all take extra parameters that are referred to as \"Type Guards\". A type guard is a basic function which takes in a value, and returns whether or not the value matches a certain criteria to be of that type. TypeScript function isString ( value : unknown ) : value is string { return typeIs ( value , \"string\" ); } function isNumber ( value : unknown ) : value is number { return typeIs ( value , \"number\" ); } Lua function isString ( value ) return type ( value ) == \"string\" end function isNumber ( value ) return type ( value ) == \"number\" end So in our above case, if we wanted to enforce our RemoteEvent to only take in a string, and a number: TypeScript import Net from \"@rbxts/net\" ; const addItemToPlayer = new Net . ServerEvent ( \"AddItemToPlayer\" , isString , isNumber ); // Take note of 'isString' and 'isNumber' use in the constructor here. // Also the types can be omitted as TypeScript knows what the types are now. addItemToPlayer . Connect (( player , itemId , amount ) => { // itemId will always be a string // amount will always be a number // If either are wrong, it will get discarded }) Lua local Net = require ( path_to_net ) local addItemToPlayer = Net . ServerEvent . new ( \"AddItemToPlayer\" , isString , isNumber ) -- Take note of 'isString' and 'isNumber' use in the constructor here. addItemToPlayer : Connect ( function ( player , itemId , amount ) -- itemId will always be a string -- amount will always be a number -- If either are wrong, it will get discarded end )","title":"How to enforce types"},{"location":"type-safety/#using-an-existing-type-guard-library","text":"Writing your own functions for type guards, while doable can get tedious. There is already a library called 't' which is a good solution for this.","title":"Using an existing type guard library"},{"location":"type-safety/#typescript","text":"You can install it using: npm i @rbxts/t Then with our above example, simply replace isString and isNUmber with t.string and t.number . There are also other type guards in that library that you could use for different argument types. import t from \"@rbxts/t\" ; import Net from \"@rbxts/net\" ; const addItemToPlayer = new Net . ServerEvent ( \"AddItemToPlayer\" , t . string , t . number ); addItemToPlayer . Connect (( player , itemId , amount ) => { // itemId will always be a string // amount will always be a number // If either are wrong, it will get discarded })","title":"TypeScript"},{"location":"type-safety/#lua","text":"If you want the Lua version of t, it is available here . local Net = require ( path_to_net ) local t = require ( path_to_t ) local addItemToPlayer = Net . ServerEvent . new ( \"AddItemToPlayer\" , t . string , t . number ) addItemToPlayer : Connect ( function ( player , itemId , amount ) -- itemId will always be a string -- amount will always be a number -- If either are wrong, it will get discarded end )","title":"Lua"},{"location":"class/NetClientAsyncFunction/","text":"NetClientAsyncFunction is a class that functions similarly to a NetServerFunction , however unlike a NetClientFunction it uses events rather than functions behind the scenes. The advantage to this is it allows for timeouts. NetClientAsyncFunction also supports returning promises in the callback function. Constructor \u00b6 new ( name : string ) => NetClientAsyncFunction ; name The name of the NetClientAsyncFunction Methods \u00b6 CallPlayerAsync \u00b6 CallServerAsync (... args : Array < unknown > ) : Promise < unknown > ; Calls the server and returns a promise that will either resolve with the returned value from the server, or reject if the timeout is reached. Example usage TypeScript const myAsyncFunction = new Net . ClientAsyncFunction ( \"MyAsyncFunction\" ); myAsyncFunction . CallServerAsync ( \"SayHello\" ). then ( result => { print ( \"The server said\" , result ); }). catch (( err : string ) => { print ( \"Failed to get message from server. :(\" , err ); }) Lua local myAsyncFunction = Net . ClientAsyncFunction . new ( \"MyAsyncFunction\" ) myAsyncFunction : CallServerAsync ( \"SayHello\" ): andThen ( function ( result ) print ( \"The server said\" , result ) end ): catch ( function ( err ) print ( \"Failed to get message from server. :(\" , err ) end ) SetCallback \u00b6 SetCallback ( callback : Callback ) : void ; Sets the callback for this function Example TypeScript const myAsyncFunction = new Net . ClientAsyncFunction ( \"MyAsyncFunction\" ); myAsyncFunction . SetCallback (( message : string ) => { return \"You sent me\" + message ; }); Lua local myAsyncFunction = Net . ClientAsyncFunction . new ( \"MyAsyncFunction\" ) myAsyncFunction : SetCallback ( function ( message ) return \"You sent me\" .. message end ) SetCallTimeout \u00b6 SetCallTimeout ( seconds : number ) : void ; SetCallTimeout \u00b6 GetCallTimeout () : number ;","title":"ClientAsyncFunction"},{"location":"class/NetClientAsyncFunction/#constructor","text":"new ( name : string ) => NetClientAsyncFunction ; name The name of the NetClientAsyncFunction","title":"Constructor"},{"location":"class/NetClientAsyncFunction/#methods","text":"","title":"Methods"},{"location":"class/NetClientAsyncFunction/#callplayerasync","text":"CallServerAsync (... args : Array < unknown > ) : Promise < unknown > ; Calls the server and returns a promise that will either resolve with the returned value from the server, or reject if the timeout is reached. Example usage TypeScript const myAsyncFunction = new Net . ClientAsyncFunction ( \"MyAsyncFunction\" ); myAsyncFunction . CallServerAsync ( \"SayHello\" ). then ( result => { print ( \"The server said\" , result ); }). catch (( err : string ) => { print ( \"Failed to get message from server. :(\" , err ); }) Lua local myAsyncFunction = Net . ClientAsyncFunction . new ( \"MyAsyncFunction\" ) myAsyncFunction : CallServerAsync ( \"SayHello\" ): andThen ( function ( result ) print ( \"The server said\" , result ) end ): catch ( function ( err ) print ( \"Failed to get message from server. :(\" , err ) end )","title":"CallPlayerAsync"},{"location":"class/NetClientAsyncFunction/#setcallback","text":"SetCallback ( callback : Callback ) : void ; Sets the callback for this function Example TypeScript const myAsyncFunction = new Net . ClientAsyncFunction ( \"MyAsyncFunction\" ); myAsyncFunction . SetCallback (( message : string ) => { return \"You sent me\" + message ; }); Lua local myAsyncFunction = Net . ClientAsyncFunction . new ( \"MyAsyncFunction\" ) myAsyncFunction : SetCallback ( function ( message ) return \"You sent me\" .. message end )","title":"SetCallback"},{"location":"class/NetClientAsyncFunction/#setcalltimeout","text":"SetCallTimeout ( seconds : number ) : void ;","title":"SetCallTimeout"},{"location":"class/NetClientAsyncFunction/#setcalltimeout_1","text":"GetCallTimeout () : number ;","title":"SetCallTimeout"},{"location":"class/NetClientEvent/","text":"Constructor \u00b6 new ( name : string ) => NetClientEvent ; name The name of the NetClientEvent Methods \u00b6 Connect \u00b6 SendToServer \u00b6","title":"ClientEvent"},{"location":"class/NetClientEvent/#constructor","text":"new ( name : string ) => NetClientEvent ; name The name of the NetClientEvent","title":"Constructor"},{"location":"class/NetClientEvent/#methods","text":"","title":"Methods"},{"location":"class/NetClientEvent/#connect","text":"","title":"Connect"},{"location":"class/NetClientEvent/#sendtoserver","text":"","title":"SendToServer"},{"location":"class/NetClientFunction/","text":"Constructor \u00b6 new ( name : string ) => NetClientFunction ; name The name of the NetClientEvent Methods \u00b6 SetCallback \u00b6 CallServer \u00b6 CallServerAsync \u00b6","title":"ClientFunction"},{"location":"class/NetClientFunction/#constructor","text":"new ( name : string ) => NetClientFunction ; name The name of the NetClientEvent","title":"Constructor"},{"location":"class/NetClientFunction/#methods","text":"","title":"Methods"},{"location":"class/NetClientFunction/#setcallback","text":"","title":"SetCallback"},{"location":"class/NetClientFunction/#callserver","text":"","title":"CallServer"},{"location":"class/NetClientFunction/#callserverasync","text":"","title":"CallServerAsync"},{"location":"class/NetServerAsyncFunction/","text":"NetServerAsyncFunction is a class that functions similarly to a NetServerFunction , however unlike a NetServerFunction it uses events rather than functions behind the scenes. The advantage to this is that it supports calling the client (player) directly unlike NetServerFunction , as it has built in timeouts. NetServerAsyncFunction also supports returning promises in the callback function. Constructor \u00b6 new ( name : string , ... typeCheckers : TypeChecks ) => NetServerAsyncFunction ; name The name of the NetServerAsyncFunction typeCheckers These are type checks to narrow down the types for the callback. You can use libraries like t for this. Example usage: TypeScript import t from \"@rbxts/t\" ; const myAsyncFunction = new Net . ServerAsyncFunction ( \"MyAsyncFunc\" , t . string , t . number ); Lua local t = require ( ReplicatedStorage . t ) local myAsyncFunction = Net . ServerAsyncFunction . new ( \"MyAsyncFunc\" , t . string , t . number ) The first parameter of the callback function in the example is guaranteed to be a string, the second is guaranteed to be a number. You can add even more type checks as parameters to the constructor, as many as required. Methods \u00b6 CallPlayerAsync \u00b6 CallPlayerAsync ( player : Player , ... args : Array < unknown > ) : Promise < unknown > ; Calls the specified player and returns a promise that will either resolve with the returned value from the player, or reject if the timeout is reached. Example usage TypeScript const myAsyncFunction = new Net . ServerAsyncFunction ( \"MyAsyncFunction\" ); myAsyncFunction . CallPlayerAsync ( game . Players . Vorlias , \"SayHello\" ). then ( result => { print ( \"Vorlias said\" , result ); }). catch (( err : string ) => { print ( \"Failed to get message from Vorlias. :(\" , err ); }) Lua local myAsyncFunction = Net . ServerAsyncFunction . new ( \"MyAsyncFunction\" ) myAsyncFunction : CallPlayerAsync ( game . Players . Vorlias , \"SayHello\" ): andThen ( function ( result ) print ( \"Vorlias said\" , result ) end ): catch ( function ( err ) print ( \"Failed to get message from Vorlias. :(\" , err ) end ) SetCallback \u00b6 SetCallback ( callback : Callback ) : void ; Sets the callback for this function Example TypeScript const myAsyncFunction = new Net . ServerAsyncFunction ( \"MyAsyncFunction\" , t . string ); myAsyncFunction . SetCallback (( player : Player , message : string ) => { return \"You sent me\" + message ; }); Lua local myAsyncFunction = Net . ServerAsyncFunction . new ( \"MyAsyncFunction\" ) myAsyncFunction : SetCallback ( function ( player , message ) return \"You sent me\" .. message end ) SetCallTimeout \u00b6 SetCallTimeout ( seconds : number ) : void ; SetCallTimeout \u00b6 GetCallTimeout () : number ;","title":"ServerAsyncFunction"},{"location":"class/NetServerAsyncFunction/#constructor","text":"new ( name : string , ... typeCheckers : TypeChecks ) => NetServerAsyncFunction ; name The name of the NetServerAsyncFunction typeCheckers These are type checks to narrow down the types for the callback. You can use libraries like t for this. Example usage: TypeScript import t from \"@rbxts/t\" ; const myAsyncFunction = new Net . ServerAsyncFunction ( \"MyAsyncFunc\" , t . string , t . number ); Lua local t = require ( ReplicatedStorage . t ) local myAsyncFunction = Net . ServerAsyncFunction . new ( \"MyAsyncFunc\" , t . string , t . number ) The first parameter of the callback function in the example is guaranteed to be a string, the second is guaranteed to be a number. You can add even more type checks as parameters to the constructor, as many as required.","title":"Constructor"},{"location":"class/NetServerAsyncFunction/#methods","text":"","title":"Methods"},{"location":"class/NetServerAsyncFunction/#callplayerasync","text":"CallPlayerAsync ( player : Player , ... args : Array < unknown > ) : Promise < unknown > ; Calls the specified player and returns a promise that will either resolve with the returned value from the player, or reject if the timeout is reached. Example usage TypeScript const myAsyncFunction = new Net . ServerAsyncFunction ( \"MyAsyncFunction\" ); myAsyncFunction . CallPlayerAsync ( game . Players . Vorlias , \"SayHello\" ). then ( result => { print ( \"Vorlias said\" , result ); }). catch (( err : string ) => { print ( \"Failed to get message from Vorlias. :(\" , err ); }) Lua local myAsyncFunction = Net . ServerAsyncFunction . new ( \"MyAsyncFunction\" ) myAsyncFunction : CallPlayerAsync ( game . Players . Vorlias , \"SayHello\" ): andThen ( function ( result ) print ( \"Vorlias said\" , result ) end ): catch ( function ( err ) print ( \"Failed to get message from Vorlias. :(\" , err ) end )","title":"CallPlayerAsync"},{"location":"class/NetServerAsyncFunction/#setcallback","text":"SetCallback ( callback : Callback ) : void ; Sets the callback for this function Example TypeScript const myAsyncFunction = new Net . ServerAsyncFunction ( \"MyAsyncFunction\" , t . string ); myAsyncFunction . SetCallback (( player : Player , message : string ) => { return \"You sent me\" + message ; }); Lua local myAsyncFunction = Net . ServerAsyncFunction . new ( \"MyAsyncFunction\" ) myAsyncFunction : SetCallback ( function ( player , message ) return \"You sent me\" .. message end )","title":"SetCallback"},{"location":"class/NetServerAsyncFunction/#setcalltimeout","text":"SetCallTimeout ( seconds : number ) : void ;","title":"SetCallTimeout"},{"location":"class/NetServerAsyncFunction/#setcalltimeout_1","text":"GetCallTimeout () : number ;","title":"SetCallTimeout"},{"location":"class/NetServerEvent/","text":"Constructor \u00b6 new ( name : string , ... typeCheckers : TypeChecks ) => NetServerEvent ; name The name of the NetServerEvent typeCheckers These are type checks to narrow down the types for the connected function. You can use libraries like t for this. Example usage: TypeScript import t from \"@rbxts/t\" ; const myEvent = new Net . ServerEvent ( \"MyEvent\" , t . string , t . number ); Lua local t = require ( ReplicatedStorage . t ) local myEvent = Net . ServerEvent . new ( \"MyEvent\" , t . string , t . number ) The first parameter of the connected function in the example is guaranteed to be a string, the second is guaranteed to be a number. You can add even more type checks as parameters to the constructor, as many as required. Methods \u00b6 Connect \u00b6 SendToAllPlayers \u00b6 SendToAllPlayersExcept \u00b6 SendToPlayer \u00b6 SendToPlayers \u00b6","title":"ServerEvent"},{"location":"class/NetServerEvent/#constructor","text":"new ( name : string , ... typeCheckers : TypeChecks ) => NetServerEvent ; name The name of the NetServerEvent typeCheckers These are type checks to narrow down the types for the connected function. You can use libraries like t for this. Example usage: TypeScript import t from \"@rbxts/t\" ; const myEvent = new Net . ServerEvent ( \"MyEvent\" , t . string , t . number ); Lua local t = require ( ReplicatedStorage . t ) local myEvent = Net . ServerEvent . new ( \"MyEvent\" , t . string , t . number ) The first parameter of the connected function in the example is guaranteed to be a string, the second is guaranteed to be a number. You can add even more type checks as parameters to the constructor, as many as required.","title":"Constructor"},{"location":"class/NetServerEvent/#methods","text":"","title":"Methods"},{"location":"class/NetServerEvent/#connect","text":"","title":"Connect"},{"location":"class/NetServerEvent/#sendtoallplayers","text":"","title":"SendToAllPlayers"},{"location":"class/NetServerEvent/#sendtoallplayersexcept","text":"","title":"SendToAllPlayersExcept"},{"location":"class/NetServerEvent/#sendtoplayer","text":"","title":"SendToPlayer"},{"location":"class/NetServerEvent/#sendtoplayers","text":"","title":"SendToPlayers"},{"location":"class/NetServerFunction/","text":"Constructor \u00b6 new ( name : string , ... typeCheckers : TypeChecks ) => NetServerFunction ; name The name of the NetServerEvent typeCheckers These are type checks to narrow down the types for the callback. You can use libraries like t for this. Example usage: TypeScript import t from \"@rbxts/t\" ; const myFunction = new Net . ServerFunction ( \"MyFunction\" , t . string , t . number ); Lua local t = require ( ReplicatedStorage . t ) local myFunction = Net . ServerFunction . new ( \"MyFunction\" , t . string , t . number ) The first parameter of the callback function in the example is guaranteed to be a string, the second is guaranteed to be a number. You can add even more type checks as parameters to the constructor, as many as required. Methods \u00b6 SetCallback \u00b6 SetClientCache \u00b6 GetClientCache \u00b6","title":"ServerFunction"},{"location":"class/NetServerFunction/#constructor","text":"new ( name : string , ... typeCheckers : TypeChecks ) => NetServerFunction ; name The name of the NetServerEvent typeCheckers These are type checks to narrow down the types for the callback. You can use libraries like t for this. Example usage: TypeScript import t from \"@rbxts/t\" ; const myFunction = new Net . ServerFunction ( \"MyFunction\" , t . string , t . number ); Lua local t = require ( ReplicatedStorage . t ) local myFunction = Net . ServerFunction . new ( \"MyFunction\" , t . string , t . number ) The first parameter of the callback function in the example is guaranteed to be a string, the second is guaranteed to be a number. You can add even more type checks as parameters to the constructor, as many as required.","title":"Constructor"},{"location":"class/NetServerFunction/#methods","text":"","title":"Methods"},{"location":"class/NetServerFunction/#setcallback","text":"","title":"SetCallback"},{"location":"class/NetServerFunction/#setclientcache","text":"","title":"SetClientCache"},{"location":"class/NetServerFunction/#getclientcache","text":"","title":"GetClientCache"}]}