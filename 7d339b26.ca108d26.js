(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{116:function(e,t,n){"use strict";var a=n(0),r=n.n(a),o=n(113),l=n(100),i=n(60),c=n.n(i),s=37,u=39;var b=function(e){var t=e.lazy,n=e.block,i=e.defaultValue,b=e.values,d=e.groupId,p=e.className,m=Object(o.a)(),y=m.tabGroupChoices,h=m.setTabGroupChoices,f=Object(a.useState)(i),v=f[0],g=f[1],w=a.Children.toArray(e.children);if(null!=d){var O=y[d];null!=O&&O!==v&&b.some((function(e){return e.value===O}))&&g(O)}var j=function(e){g(e),null!=d&&h(d,e)},N=[];return r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(l.a)("tabs",{"tabs--block":n},p)},b.map((function(e){var t=e.value,n=e.label;return r.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":v===t,className:Object(l.a)("tabs__item",c.a.tabItem,{"tabs__item--active":v===t}),key:t,ref:function(e){return N.push(e)},onKeyDown:function(e){!function(e,t,n){switch(n.keyCode){case u:!function(e,t){var n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()}(e,t);break;case s:!function(e,t){var n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()}(e,t)}}(N,e.target,e)},onFocus:function(){return j(t)},onClick:function(){j(t)}},n)}))),t?Object(a.cloneElement)(w.filter((function(e){return e.props.value===v}))[0],{className:"margin-vert--md"}):r.a.createElement("div",{className:"margin-vert--md"},w.map((function(e,t){return Object(a.cloneElement)(e,{key:t,hidden:e.props.value!==v})}))))},d=n(3);var p=function(e){var t=e.children,n=e.hidden,a=e.className;return r.a.createElement("div",Object(d.a)({role:"tabpanel"},{hidden:n,className:a}),t)};t.a=function(e){var t=e.children,n=t[0],a=t[1];return console.log(n,a),r.a.createElement(b,{defaultValue:"ts",groupId:"code",values:[{label:"roblox-ts",value:"ts"},{label:"luau",value:"lua"}]},r.a.createElement(p,{value:"ts"},n),r.a.createElement(p,{value:"lua"},a))}},84:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return b}));var a=n(3),r=n(7),o=(n(0),n(103)),l=n(116),i={id:"type-safety",title:"Type Safety",sidebar_label:"Type Safety",slug:"/type-safety"},c={unversionedId:"type-safety",id:"version-1.3.0/type-safety",isDocsHomePage:!1,title:"Type Safety",description:"It's important when you recieve events or calls from the server that you ensure the types are correct, otherwise unwanted errors may pop up.",source:"@site/versioned_docs/version-1.3.0/type-safety.md",slug:"/type-safety",permalink:"/rbx-net/docs/1.3.x/type-safety",editUrl:"https://github.com/roblox-aurora/rbx-net/edit/main/docs/versioned_docs/version-1.3.0/type-safety.md",version:"1.3.0",sidebar_label:"Type Safety",sidebar:"docs",previous:{title:"Install for TypeScript",permalink:"/rbx-net/docs/1.3.x/install"},next:{title:"Caching",permalink:"/rbx-net/docs/1.3.x/caching"}},s=[{value:"How to enforce types",id:"how-to-enforce-types",children:[]},{value:"Using an existing type guard library",id:"using-an-existing-type-guard-library",children:[{value:"TypeScript",id:"typescript",children:[]},{value:"Lua",id:"lua",children:[]}]}],u={toc:s};function b(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"It's important when you recieve events or calls from the server that you ensure the types are correct, otherwise unwanted errors may pop up."),Object(o.b)("p",null,"By default, events and callbacks are typed to ",Object(o.b)("inlineCode",{parentName:"p"},"unknown[]"),". This may become a bit problematic when you're trying to set specific parameter types as such:"),Object(o.b)("p",null,"It's important when you recieve events or calls from the server that you ensure the types are correct, otherwise unwanted errors may pop up."),Object(o.b)("p",null,"By default, events and callbacks are typed to ",Object(o.b)("inlineCode",{parentName:"p"},"unknown[]"),". This may become a bit problematic when you're trying to set specific parameter types as such:"),Object(o.b)(l.a,{mdxType:"Code"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'const addItemToPlayer = new Net.ServerEvent("AddItemToPlayer");\naddItemToPlayer.Connect((player: Player, itemId: string, amount: number) => {\n    // itemId and amount will show with an error\n    // since unknown cannot be converted to number\n}) \n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'local addItemToPlayer = Net.ServerEvent.new("AddItemToPlayer")\naddItemToPlayer:Connect(function(player, itemId, amount) \n    -- itemId and amount could be anything here in Lua\n    -- This can lead to bugs, especially with exploiters\nend)\n'))),Object(o.b)("h2",{id:"how-to-enforce-types"},"How to enforce types"),Object(o.b)("p",null,"The constructors for ",Object(o.b)("inlineCode",{parentName:"p"},"Net.ServerEvent"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Net.ServerFunction")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Net.ServerAsyncFunction"),' all take extra parameters that are referred to as "Type Guards".'),Object(o.b)("p",null,"A type guard is a basic function which takes in a value, and returns whether or not the value matches a certain criteria to be of that type."),Object(o.b)(l.a,{mdxType:"Code"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'function isString(value: unknown): value is string {\n    return typeIs(value, "string");\n}\n\nfunction isNumber(value: unknown): value is number {\n    return typeIs(value, "number");\n}\n')),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'function isString(value)\n    return type(value) == "string"\nend\n\nfunction isNumber(value)\n    return type(value) == "number"\nend\n'))),Object(o.b)("p",null,"So in our above case, if we wanted to enforce our RemoteEvent to only take in a string, and a number:"),Object(o.b)(l.a,{mdxType:"Code"},Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import Net from \"@rbxts/net\";\n\nconst addItemToPlayer = new Net.ServerEvent(\"AddItemToPlayer\", isString, isNumber);\n// Take note of 'isString' and 'isNumber' use in the constructor here.\n// Also the types can be omitted as TypeScript knows what the types are now.\naddItemToPlayer.Connect((player, itemId, amount) => {\n    // itemId will always be a string\n    // amount will always be a number\n    // If either are wrong, it will get discarded\n}) \n")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),"local Net = require(path_to_net)\n\nlocal addItemToPlayer = Net.ServerEvent.new(\"AddItemToPlayer\", isString, isNumber)\n-- Take note of 'isString' and 'isNumber' use in the constructor here.\naddItemToPlayer:Connect(function(player, itemId, amount) \n    -- itemId will always be a string\n    -- amount will always be a number\n    -- If either are wrong, it will get discarded\nend)\n"))),Object(o.b)("h2",{id:"using-an-existing-type-guard-library"},"Using an existing type guard library"),Object(o.b)("p",null,"Writing your own functions for type guards, while doable can get tedious. There is already a library called 't' which is a good solution for this."),Object(o.b)("h3",{id:"typescript"},"TypeScript"),Object(o.b)("p",null,"You can ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.npmjs.com/package/@rbxts/t"}),"install it")," using:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"npm i @rbxts/t\n")),Object(o.b)("p",null,"Then with our above example, simply replace ",Object(o.b)("inlineCode",{parentName:"p"},"isString")," and ",Object(o.b)("inlineCode",{parentName:"p"},"isNumber")," with ",Object(o.b)("inlineCode",{parentName:"p"},"t.string")," and ",Object(o.b)("inlineCode",{parentName:"p"},"t.number"),". There are also other type guards in that library that you could use for different argument types."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'import t from "@rbxts/t";\nimport Net from "@rbxts/net";\n\nconst addItemToPlayer = new Net.ServerEvent("AddItemToPlayer", t.string, t.number);\naddItemToPlayer.Connect((player, itemId, amount) => {\n    // itemId will always be a string\n    // amount will always be a number\n    // If either are wrong, it will get discarded\n}) \n')),Object(o.b)("h3",{id:"lua"},"Lua"),Object(o.b)("p",null,"If you want the Lua version of t, it is available ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/osyrisrblx/t"}),"here"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-lua"}),'local Net = require(path_to_net)\nlocal t = require(path_to_t)\n\nlocal addItemToPlayer = Net.ServerEvent.new("AddItemToPlayer", t.string, t.number)\naddItemToPlayer:Connect(function(player, itemId, amount) \n    -- itemId will always be a string\n    -- amount will always be a number\n    -- If either are wrong, it will get discarded\nend)\n')))}b.isMDXComponent=!0}}]);